qemu-7.2.0
==========

  SKIP: [-Wimplicit-function-declaration]
  SKIP: [-Wnested-externs]

  TRUE: ../disas/sparc.c:2691:9: warning: dereference of possibly-NULL ‘sorted_opcodes’ [CWE-690] [-Wanalyzer-possible-null-dereference]
  TRUE: ../subprojects/libvhost-user/libvhost-user.c:2550:5: warning: dereference of possibly-NULL ‘elem’ [CWE-690] [-Wanalyzer-possible-null-dereference]

  TRUE: ../tests/qtest/libqtest.c:631:73: warning: check of ‘*words’ for NULL after already dereferencing it [-Wanalyzer-deref-before-check]
     In qtest_rsp_args, there's this deref:
       if (strcmp(words[0], "IRQ") == 0) {
     before this check:
       g_assert(words[0] != NULL);
     Test coverage added to gcc upstream in r13-5654-g598e10cf415f0a.

  False positives already in GCC bugzilla
  =======================================
    FALSE: ../qobject/json-parser.c:270:15: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]
    FALSE: ../qobject/json-parser.c:382:15: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]
    FALSE: ../qobject/json-parser.c:545:16: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]
    FALSE: ../qobject/json-parser.c:547:16: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]
      https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108524
    FALSE: ../hw/tpm/tpm_tis_common.c:311:21: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]
    FALSE: ../hw/tpm/tpm_tis_common.c:436:9: warning: infinite recursion [CWE-674] [-Wanalyzer-infinite-recursion]
     Am assuming these were false positives; went away with fix for https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108524

    FALSE: ../tests/qtest/libqtest.c:696:11: warning: ‘listen’ on non-stream-socket file descriptor ‘sock’ [-Wanalyzer-fd-type-mismatch]
      https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108633

  False positives not yet in GCC bugzilla
  =======================================

    FALSE: ../target/i386/kvm/kvm.c:5145:37: warning: buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]
    FALSE: ../target/i386/kvm/kvm.c:5147:28: warning: buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]
    FALSE: ../target/i386/kvm/kvm.c:5148:37: warning: buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]
      It's considering accessing hw_breakpoint[n].addr; for some constant n in the loop, when it has 4 elements; presumably it's unrolled it, and doesn't know that there's a limit, and nb_hw_breakpoint is limited in kvm_arch_insert_hw_breakpoint.
      In theory it might be possible to statically prove that 0 <= nb_hw_breakpoint < 4 by analyzing kvm_arch_insert_hw_breakpoint.

  To be classified
  ================
    TODO: ../target/ppc/misc_helper.c:78:38: warning: shift by count (‘1024’) >= precision of type (‘64’) [-Wanalyzer-shift-count-overflow]
    TODO: ../tests/qtest/libqtest.c:696:11: warning: ‘listen’ on possibly invalid file descriptor ‘sock’ [-Wanalyzer-fd-use-without-check]
    TODO: [-Wanalyzer-deref-before-check]
    TODO: [-Wanalyzer-malloc-leak]
    TODO: [-Wanalyzer-null-argument]
    TODO: [-Wanalyzer-null-dereference]

    TODO: ../libdecnumber/decNumber.c:6530:19: warning: buffer over-read [CWE-126] [-Wanalyzer-out-of-bounds]
      In decUnitAddSub

    TODO: [-Wanalyzer-use-of-uninitialized-value]



